<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【实例2】24点游戏</title>
      <link href="/Point-24-Game.html"/>
      <url>/Point-24-Game.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面我们描述了如何通过表达式求值，今天我们玩个游戏——24点</p></blockquote><h2 id="描述问题"><a href="#描述问题" class="headerlink" title="描述问题"></a>描述问题</h2><p>在确认程序编写之前我们需要思考如何描述，表达问题</p><p>算法具有五个特性</p><blockquote><p>1.输入：在算法中可以有零个或者多个输入</p><p>2.输出：在算法中至少有一个或者多个输出</p><p>3.有穷行：在执行有限的步骤之后，自动结束不会出现无限循环并且每一个步骤在可接受的时间内完成</p><p>4.确定性：算法的每一个步骤都具有确定的含义，不会出现二义性</p><p>5.可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限的次数完成</p></blockquote><p>那么哪两个适用于描述问题呢？答案是<code>输入和输出</code></p><p>描述问题，我们只需要抓住输入和输出就够了。至于什么其他的问题背景，对于毫无意义。找到问题的输入和输出之后，我们进入抽象化的世界，</p><p>所以描述任何问题最关键的是要找到问题的输入和输出。</p><p><strong>24点的输入是什么？四个整数，每个整数都在1~13之间</strong></p><p><strong>输出呢？输出就是要找一个表达式，加减乘除算运算完成后等于24。如果找不到输出<code>无解</code>，找到就输出那个<code>表达式</code></strong></p><p>有了输入和输出之后，24点问题就算是描述的非常清晰。</p><p><strong>计算机专业描述问题，只需要抓住啊两个特点：输入和输出</strong></p><p>不是说问题背景不需要，而是说，描述问题背景是为了找到输入与输出！与输入输出无关的背景可以酌情忽略。</p><h2 id="解决问题方法"><a href="#解决问题方法" class="headerlink" title="解决问题方法"></a>解决问题方法</h2><p>输入和输出找到之后需要找解决方案，解决方案找到之后，把解决方案变成算法。把解决方案变成算法的过程可能需要咨询领域专家。算法知道后，我们的路就好走了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>举例子：</p><p>24点游戏我们需要输入四个数字，最后要找一个表达式，加减乘除算运算完成后等于24。</p><p>比如说有3，7，9，10四个数</p><p>我们计算的时候，找到两个数直接通过加减乘除通过双目运算符直接进行计算【Ps：我们需最终要把问题落实在基本操作上，而24点游戏的基本操作就是加减乘除】</p><p>双目运算符直接进行计算，需要两个数，所以第一步，我们先要从四个数中抽出两个数进行加减乘除</p><p>四个数里面取两个数，六种取法：</p><p>3，7，9，10四个数</p><p>取两个数：3,7 3,9 3,10 7,9 7,10 9,10</p><p>我们单拿<code>3,7</code>来看，结果为<code>10,-4,4,21，(不能整除)</code></p><p>由两个数可以算出4~5种可能：<code>10,9,10</code>；<code>-4,9,10</code> ； <code>4,9,10</code>；<code>21,9,10</code>，不能整除。</p><p>四个变成三个数一共有24<del>30（6 * 4</del>6 * 5）种可能。【6为四个数抽出两个数的可能性】</p><p>…………以此类推…………</p><p>4个变为1个数，一共有1152~2250种变法【(C_4^2<em>4</em>C_3^2<em>4</em>C_2^2*4&#x3D;1152】</p><p>然后我们从这些数中寻找24，并且将其溯源，寻找他的运算符号以及从哪些数变化而来</p><p>到此，我们的基本流程几乎了解，也就是说我们对于这个问题的策略基本上可以掌握</p><blockquote><p>算法策略和算法是有区别的,它们是算法设计中的两个方面，算法策略是面向问题的,算法是面向实现的；但二者又是不可分的,首先是通过算法策略才找出解决问题的算法，其次对于用不同算法求解的问题算法策略是自然不同的。</p></blockquote><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>我们发现，这种流程颠覆了我们正常游戏的思维。它是用最基本的加减乘除操作，因为我们发现，不管4个数是如何变化，运算的时候都是抽取两个数进行计算。并且最多计算三轮，第一轮4个数变成3个数，第二轮3个数变成2个数，第三轮2个数变成1个数。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我们由上可以找到一个<strong>动态数据结构</strong>去配合实现，我们发现，在上述流程中，四个数转三个数，将会生成多个数（4~5种可能），然后在每一种可能中又包含多种可能，这种<strong>连续一对多</strong>的情况下，我们不由的想到一种数据结构——<strong>树</strong></p><p>从<code>策略</code>可知，我们计算了三轮，所以很容易判断树的高度为4，并且这个高度为4的树的叶子结点最多为2250个、最少有1152个。</p><blockquote><p>分析问题的过程中可能有一系列的回答或者决策。</p><p>所以这个数习惯上把它叫做分析树，也有时候把它叫做决策树</p><p>他实际上和计算机与人类在做围棋博弈的时候的那个思维方法是一样的，所以他也叫博弈树</p><p><strong>（分析树是动态的）</strong></p></blockquote><p>所以此类问题我们可以使用树来进行存储记录</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>每个叶子结点都拥有一个int型的数据，而这些数据需要用一个int型容器进行存放，而最方便的int型容器是<code>vector</code></p><pre><code class="c++">struct element&#123;    int number;    std::string trace;//string即为字符串&#125;;struct NODE&#123;    std::vector&lt;element&gt; data;    std::vector&lt;NODE&gt; children;//子节点 &#125; ana_tree;//定义分析（analyse）树；ADT抽象数据类型 vector&lt;NODE&gt;（类似于递归结构） </code></pre><p>对于分析树的根节点来说，里面拥有四个整数；而对于叶子结点来说，每个结点只有一个整数。</p><blockquote><p>抽象数据类型（Abstract Data Type，ADT）是将数据对象、数据对象之间的关系和数据对象的基本操作封装在一起的一种表达方式，它和工程中的应用是一致的。</p><p>在工程项目中，开始编程之前，首先列出程序需要完成的功能任务，先不用管具体怎么实现，实现细节在项目后期完成，一开始只是抽象出有哪些基本操作。把这些操作项封装为抽象数据类型，等待后面具体实现这些操作。而其他对象如果想调用这些操作，只需要按照规定好的参数接口调用，并不需要知道具体是怎么实现的，从而实现了数据封装和信息隐藏。</p><p>在 C++ 中可以用类的声明表示抽象数据类型，用类的实现来实现抽象数据类型的具体操作。</p><p><img src="https://img1.i-nmb.cn/img/1-20040912553LU.gif" alt="ADT三元素示意图"></p><p>抽象数据类型可以用以下的三元组来表示：</p><p>ADT抽象数据类型名{<br>  数据对象：&lt;数据对象的定义&gt;<br>  数据关系：&lt;数据关系的定义&gt;<br>  基本操作：&lt;基本操作的定义&gt;<br>} ADT抽象数据类型名、</p><p>引用于：<a href="http://c.biancheng.net/view/7526.html">抽象数据类型（ADT）是什么？ (biancheng.net)</a></p></blockquote><p>定义好树之后，我们开始在main函数中初始化，先给ana_tree中存放两个值</p><pre><code class="c++">int main()&#123;    ana_tree.data = &#123;3,6&#125;;    step(ana_tree);    for(auto child:ana_tree.children)&#123;        for(auto num:child.data)&#123;            printf(&quot;%d&quot;,num);        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="step"><a href="#step" class="headerlink" title="step"></a>step</h3><p>其中step中的需要的操作为：n个数中取出两个，然后这两个和剩下的哪些没有取出的数变成4~5个子节点。</p><h4 id="n个数中取出两个数"><a href="#n个数中取出两个数" class="headerlink" title="n个数中取出两个数"></a>n个数中取出两个数</h4><p>实现代码如下</p><pre><code class="c++">void step(NODE&amp; tree)&#123;    for(auto i=tree.data.begin();i!=tree.data.end();++i)&#123;        for(auto j=i+1;j!=tree.data.end();++j)    &#125;&#125;//类似于冒泡排序循环</code></pre><h4 id="n个数转换为n-1"><a href="#n个数转换为n-1" class="headerlink" title="n个数转换为n-1"></a>n个数转换为n-1</h4><p>在前文介绍中，我们推断2个数合成1个数一共有4~5种可能，那么我们设定每个非叶子节点有5个子节点（如下代码中<code>t1,t2,t3,t4,t5;</code>）并且使用<code>.data.push_back</code>将加减乘除的得数赋予<code>t1,t2,t3,t4,t5;</code>，其次使用<code>tree.children.push_back</code>将<code>t1,t2,t3,t4,t5;</code>作为孩子结点，其中，在进行除法（<code>t5</code>）时需要进行<strong>判断除数是否为0以及是否能够整除</strong></p><pre><code class="C++">void step(NODE&amp; tree)&#123;    for(auto i=tree.data.begin();i!=tree.data.end();++i)&#123;        for(auto j=i+1;j!=tree.data.end();++j)&#123;            NODE t1,t2,t3,t4,t5;//孩子结点             int x=*i,y=*j;            t1.data.push_back(x+y);             t2.data.push_back(x-y);             t3.data.push_back(y-x);             t4.data.push_back(x*y);             tree.children.push_back(t1);            tree.children.push_back(t2);            tree.children.push_back(t3);            tree.children.push_back(t4);                                    if(x&amp;&amp;y/*排除0*/)                if(x%y==0)&#123;                    t5.data.push_back(x/y);                     tree.children.push_back(t5);                &#125;                                    else if(y%x==0)&#123;                    t5.data.push_back(y/x);                     tree.children.push_back(t5);                &#125;        &#125;    &#125;&#125;</code></pre><p>此时我们的<code>main</code>函数中只在根节点中存放了两个数，为了验证step函数是否正确，我们需要一个输出</p><pre><code class="c++">int main()&#123;    ana_tree.data = &#123;3,7&#125;;    step(ana_tree);    for(auto child:ana_tree.children)&#123;        for(auto num:child.data)&#123;            printf(&quot;%d\t&quot;,num);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125; </code></pre><blockquote><p>child就是每个子节点，num是子节点中所有的数；然后把每个子节点的数进行输出</p></blockquote><h4 id="将n-2个数加入到子节点"><a href="#将n-2个数加入到子节点" class="headerlink" title="将n-2个数加入到子节点"></a>将n-2个数加入到子节点</h4><p>此时我们的程序可以计算2个数，但是我们还剩下了n-2（设最初有n个数）个数还没有放入子节点，此时这个n是个变量（我们在编写程序的时候没有确定n的个数），所以我们需要加入一个<code>for(auto k=tree.data.begin();k!=tree.data.end();++k)</code>循环，其中<code>if(k==i||k==j) continue;</code>去除i,j,将剩下的存入t1-t5；</p><p>将x记为i的数值，y记为j的数值<code>int x=i-&gt;number,y=j-&gt;number;</code></p><p>然后在t1~t5中储入格式为<code>&#123;x+y,make_trace(i,&quot;+&quot;,j)&#125;</code>来记录加减乘除的符号方便溯源</p><pre><code class="c++">void step(NODE&amp; tree)&#123;    for(auto i=tree.data.begin();i!=tree.data.end();++i)&#123;        for(auto j=i+1;j!=tree.data.end();++j)&#123;            NODE t1,t2,t3,t4,t5;//孩子结点             for(auto k=tree.data.begin();k!=tree.data.end();++k)&#123;                if(k==i||k==j) continue;                t1.data.push_back(*k);                 t2.data.push_back(*k);                 t3.data.push_back(*k);                 t4.data.push_back(*k);                t5.data.push_back(*k);            &#125;                        int x=i-&gt;number,y=j-&gt;number;            t1.data.push_back(&#123;x+y,make_trace(i,&quot;+&quot;,j)&#125;);             t2.data.push_back(&#123;x-y,make_trace(i,&quot;-&quot;,j)&#125;);             t3.data.push_back(&#123;y-x,make_trace(j,&quot;-&quot;,i)&#125;);             t4.data.push_back(&#123;x*y,make_trace(i,&quot;*&quot;,j)&#125;);                         tree.children.push_back(t1);            tree.children.push_back(t2);            tree.children.push_back(t3);            tree.children.push_back(t4);                        if(x&amp;&amp;y/*排除0*/)                if(x%y==0)&#123;                    t5.data.push_back(&#123;x/y,make_trace(i,&quot;/&quot;,j)&#125;);                     tree.children.push_back(t5);                &#125;                                    else if(y%x==0)&#123;                    t5.data.push_back(&#123;y/x,make_trace(j,&quot;/&quot;,i)&#125;);                     tree.children.push_back(t5);                &#125;        &#125;    &#125;&#125;</code></pre><p>在<code>main</code>函数中</p><pre><code class="c++">int main()&#123;    printf(&quot;请输入四个数：&quot;);     for(int i = 0;i&lt;4;++i)&#123;        int n;        scanf(&quot;%d&quot;,&amp;n);        ana_tree.data.push_back(&#123;n,std::to_string(n)&#125;);    &#125;        step(ana_tree);    for(NODE&amp; child2: ana_tree.children)&#123;        step(child2);    &#125;    for(NODE&amp; child2: ana_tree.children)&#123;        for(NODE&amp; child3: child2.children)&#123;            step(child3);        &#125;    &#125;                int count=0,j=0;    for(auto child2:ana_tree.children)&#123;        for(auto child3:child2.children)&#123;            for(auto child4:child3.children)&#123;                if(child4.data.begin()-&gt;number!=24) continue;                printf(&quot;第%d组解法：%s\n&quot;,++count,child4.data.begin()-&gt;trace.c_str());            &#125;        &#125;    &#125;        if(count==0)&#123;            printf(&quot;无解\n&quot;);         &#125;            return 0;&#125; </code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;string&gt;struct element&#123;    int number;    std::string trace;&#125;;struct NODE&#123;    std::vector&lt;element&gt; data;    std::vector&lt;NODE&gt; children;&#125; ana_tree;std::string make_trace(std::vector&lt;element&gt;::iterator i,std::string op,std::vector&lt;element&gt;::iterator j)&#123;        return &quot;(&quot;+i-&gt;trace+&quot;+&quot;+j-&gt;trace+&quot;)&quot;;&#125;void step(NODE&amp; tree)&#123;    for(auto i=tree.data.begin();i!=tree.data.end();++i)&#123;        for(auto j=i+1;j!=tree.data.end();++j)&#123;            NODE t1,t2,t3,t4,t5;            for(auto k=tree.data.begin();k!=tree.data.end();++k)&#123;                if(k==i||k==j) continue;                t1.data.push_back(*k);                 t2.data.push_back(*k);                 t3.data.push_back(*k);                 t4.data.push_back(*k);                t5.data.push_back(*k);                            &#125;            int x=i-&gt;number,y=j-&gt;number;            t1.data.push_back(&#123;x+y,make_trace(i,&quot;+&quot;,j)&#125;);             t2.data.push_back(&#123;x-y,make_trace(i,&quot;-&quot;,j)&#125;);             t3.data.push_back(&#123;y-x,make_trace(j,&quot;-&quot;,i)&#125;);             t4.data.push_back(&#123;x*y,make_trace(i,&quot;*&quot;,j)&#125;);                         tree.children.push_back(t1);            tree.children.push_back(t2);            tree.children.push_back(t3);            tree.children.push_back(t4);                                    if(x&amp;&amp;y/*排除0*/)                if(x%y==0)&#123;                    t5.data.push_back(&#123;x/y,make_trace(i,&quot;/&quot;,j)&#125;);                     tree.children.push_back(t5);                &#125;                                    else if(y%x==0)&#123;                    t5.data.push_back(&#123;y/x,make_trace(j,&quot;/&quot;,i)&#125;);                     tree.children.push_back(t5);                &#125;        &#125;    &#125;&#125;int main()&#123;    printf(&quot;请输入四个数：&quot;);     for(int i = 0;i&lt;4;++i)&#123;        int n;        scanf(&quot;%d&quot;,&amp;n);        ana_tree.data.push_back(&#123;n,std::to_string(n)&#125;);    &#125;        step(ana_tree);    for(NODE&amp; child2: ana_tree.children)&#123;        step(child2);    &#125;    for(NODE&amp; child2: ana_tree.children)&#123;        for(NODE&amp; child3: child2.children)&#123;            step(child3);        &#125;    &#125;                int count=0,j=0;    for(auto child2:ana_tree.children)&#123;        for(auto child3:child2.children)&#123;            for(auto child4:child3.children)&#123;                if(child4.data.begin()-&gt;number!=24) continue;                printf(&quot;第%d组解法：%s\n&quot;,++count,child4.data.begin()-&gt;trace.c_str());            &#125;        &#125;    &#125;        if(count==0)&#123;            printf(&quot;无解\n&quot;);         &#125;            return 0;&#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 24点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【实例1の更新2】表达式求值——加入括号运算</title>
      <link href="/example-optimization-2.html"/>
      <url>/example-optimization-2.html</url>
      
        <content type="html"><![CDATA[<p>前段时间我们制作了一个表达式求值的程序，</p><p>我们赋予他基本框架与功能：<a href="https://kcsj.i-nmb.cn/example.html">【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)</a></p><p>以及更新了一目运算符的支持：<a href="https://kcsj.i-nmb.cn/example-optimization-1.html">【实例更新】表达式求值——加入新的单目运算符 | 《课程设计》笔记 (i-nmb.cn)</a></p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>我们在经过这两个步骤之后，我们可以基本实现 表达式的求值操作 ，但是<code>L 2 8 =</code>没有括号就显得十分奇怪，并且我们在输入其他字符时报错方法还可以加以优化，让程序能够定位错误。</p><p>所以目前我们需要解决的问题有两种，即：</p><h5 id="1-加入括号进行运算"><a href="#1-加入括号进行运算" class="headerlink" title="1.加入括号进行运算"></a>1.加入括号进行运算</h5><h5 id="2-优化报错方法"><a href="#2-优化报错方法" class="headerlink" title="2.优化报错方法"></a>2.优化报错方法</h5><h2 id="一、加入括号"><a href="#一、加入括号" class="headerlink" title="一、加入括号"></a>一、加入括号</h2><p>首先我们要进行加入括号的运算方法</p><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p>1.在前面的单目运算符以及双目运算符中，我们需要进行数的运算，那么加入括号，操作数又有什么变化？</p><p>2.括号的特点是什么？他的左右运算符有没有什么特点？</p><p>3.插入括号后，具体的算法（或者说 运算流程 ）是怎么样子的？</p><p>4.如何“优雅地”添加括号并且不让程序做很大改动？</p><p>这些问题我们需要思考与解决，以下为思考解决的部分过程</p><h4 id="加入括号，操作数又有什么变化？"><a href="#加入括号，操作数又有什么变化？" class="headerlink" title="加入括号，操作数又有什么变化？"></a>加入括号，操作数又有什么变化？</h4><p>无论是单目运算符或者是双目运算符，其本质为运算符，是处理数的一种符号，只是运算过程中在处理 操作数的数目 的多少而划分。</p><p>但是<strong>括号不是数学中的运算符号</strong>，他并没有处理操作数，没有改变操作数的数目和数值，他只是单纯的改变运算符之间的优先级、只是运算顺序的辅助符号。添加括号时 在栈顶的操作数 就在栈顶，没有任何变化。</p><h4 id="括号的特点是什么？"><a href="#括号的特点是什么？" class="headerlink" title="括号的特点是什么？"></a>括号的特点是什么？</h4><p>1.因为<strong>括号不是数学中的运算符号</strong>，括号最直接的特点就是，加入左括号时，不改变在左括号<code>（</code>之前的其他符号的运算顺序，并且在右括号<code>）</code>之前，都正常运算（即括号内的正常运算），左括号需要等待右括号才进行出栈</p><p>2.由1可以推断，无论左括号前面是什么，直接进栈；左括号后面的符号只要不是右括号，左括号始终不出栈，右括号始终不进栈。</p><h4 id="具体的算法（或者说-运算流程-）"><a href="#具体的算法（或者说-运算流程-）" class="headerlink" title="具体的算法（或者说 运算流程 ）"></a>具体的算法（或者说 运算流程 ）</h4><p>比如<code>3*(2+4)=</code></p><p>首先等号入栈[<code>history.top()</code>]</p><p>第一步，<code>3</code>入栈 <code>operands</code></p><p>第二步， * 与<code>history.top()</code>（&#x3D;）优先级比较， * 入栈。</p><p>第三步，由上述问题，无论左括号前面是什么，直接进栈，所以<code>(</code>入栈</p><p>第四步，<code>2</code>入栈</p><p>第五步，左括号与+进行优先级比较，由上述括号的特点可知：左括号后面的符号只要不是右括号，左括号始终不出栈，所以开始计算</p><p>第六步，输入4入栈，两次取出栈顶的元素（4和2）并进行＋运算，得数为6，压入 <code>operands</code>栈顶，弹出 + 号</p><p>第七步，输入右括号，与栈顶<code>history.top()</code>的左括号匹配，所以弹出左括号，并且右括号始终不进栈。</p><p>第八步，输入等号，等号优先级最小，先运算现在栈顶<code>history.top()</code>的 * 号，连续从栈顶取出两个元素相乘，得数18，弹出 * 号</p><p>第九步，此时栈顶[<code>history.top()</code>]为“&#x3D;”，与输入的等号相等，程序结束，输出<code>operands.top()</code>【此时为得数】</p><h4 id="如何“优雅地”添加括号？"><a href="#如何“优雅地”添加括号？" class="headerlink" title="如何“优雅地”添加括号？"></a>如何“优雅地”添加括号？</h4><p>根据以上括号的特点及运算流程</p><p>我们可以知道：</p><p>1.无论左括号前面是什么，直接进栈；</p><p>2.左括号后面的符号只要不是右括号，左括号始终不出栈，并且将符号压入栈</p><p>3.当等到右括号，则开始计算【等到右括号，“（）”内的数计算完毕】</p><p>4.当等到右括号，则弹出左括号</p><h5 id="换成伪代码的形式"><a href="#换成伪代码的形式" class="headerlink" title="换成伪代码的形式"></a>换成伪代码的形式</h5><p>将以上四点转换成伪代码的形式：</p><ol><li><p><code>if(op==&#39;(&#39;)&#123;push(op)&#125;</code></p></li><li><p><code>top==&#39;(&#39;&amp;&amp;op!=&#39;)&#39;:push(op)</code></p></li><li><p><code>if(op==&#39;)&#39;):calc</code></p></li><li><p><code>top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;:pop(&#39;(&#39;)</code></p></li></ol><h5 id="将伪代码转换为现实"><a href="#将伪代码转换为现实" class="headerlink" title="将伪代码转换为现实"></a>将伪代码转换为现实</h5><p>以上的伪代码只是我们的“梦想”，要让其成为现实的道路并不容易。</p><p>因为我们之前的程序大体以及框架已经确定，不能重新打乱和改变。</p><p>那么我们如何“优雅地”添加括号并且不让程序做很大改动？</p><p><strong>答案是<u>把括号作为一种特殊的“运算符”加入map</u></strong></p><p>我们需要用以下特性：</p><blockquote><p>1.无论左括号前面是什么，直接进栈</p><p>2.只要不是右括号，左括号始终不出栈</p><p>3.右括号始终不进栈</p></blockquote><p>得出以下结论</p><p>1.（左括号的右优先级要非常大）</p><p>2.（左括号的左优先级要非常小）</p><p>3.（右括号的右优先级非常小）</p><p>转为代码</p><pre><code class="c++">std::map&lt;oper, prv_num_t&gt;  p_num=&#123;…………​&#123;&#39;(&#39;,&#123;99,1&#125;&#125;,//左边的优先数代表在栈顶的优先数​&#123;&#39;)&#39;,&#123;0,99&#125;&#125;,//右边的优先数代表在op中的优先数，    //因为)不可能在栈内，所以左优先数为0，代表错误…………&#125;</code></pre><p>我们重新审查代码，使用以上代码，可以实现以下目标：</p><p>1.无论左括号前面是什么，直接进栈；<code>if(op==&#39;(&#39;)&#123;push(op)&#125;</code></p><p>2.左括号后面的符号只要不是右括号，左括号始终不出栈，并且将符号压入栈 <code>top==&#39;(&#39;&amp;&amp;op!=&#39;)&#39;:push(op)</code></p><p>3.当等到右括号，则开始计算 <code>if(op==&#39;)&#39;):calc</code>【等到右括号，“（）”内的数计算完毕】</p><p>但是还有最后一点没有实现</p><p>即：4.当等到右括号，则弹出左括号<code>top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;:pop(&#39;(&#39;)</code></p><p>此时我们必须修改源代码，在之前的判断等号与哨兵相等之前（<code>if(prior(history.top(),op)==0) break;</code>）根据伪代码<code>if(top==&#39;(&#39;&amp;&amp;op==&#39;)&#39;):pop(&#39;(&#39;)</code>加入以下代码，</p><pre><code class="c++">if(op==&quot;)&quot;)&#123;            history.pop();            continue;        &#125; </code></pre><p>因为左括号的左优先数&#x3D;&#x3D;右括号的右优先数，如果经过<code>if(prior(history.top(),op)==0) break;</code>那就跳出循环，运算就出错了，所以我们应该在此之前加入代码即可</p><pre><code class="c++">while(1)    &#123;    //scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40=;3+C0=两个符号合起来，2L10=，2 10 L= ，L 2 10 =；1 2 3 + *=     scanf(&quot; %c&quot;,&amp;op);//预读下一位数     if(op==&#39;,&#39;) continue;//if(op是数字)    if(isdigit(op)) &#123;//isdigiy判断是否是数字         ungetc(op, stdin);//还回字符 ,还给stdin（键盘）         scanf(&quot;%f&quot;,&amp;x);        operands.push(x);        continue;     &#125;    while(prior(history.top(),op)&lt;0)&#123;        operands.push(calc());        history.pop();    &#125;+if(op==&#39;)&#39;)&#123;+history.pop();+continue;+&#125;         if(prior(history.top(),op)==0) break;        history.push(op);    &#125;</code></pre><p>此时我们基本<strong>实现了加入括号的问题</strong>了</p><h2 id="二、优化报错方法"><a href="#二、优化报错方法" class="headerlink" title="二、优化报错方法"></a>二、优化报错方法</h2><p>解决了上面的问题，在输入右括号而不输入左括号，或者输入其他不识别的运算符时，报错代码来自</p><img src="https://img1.i-nmb.cn/img/image-20220524233540858.png" alt="报错代码来自calc函数" style="zoom:60%;" /><p>这样不利于我们定位出错的位置，所以我们需要优化程序：优化报错方法</p><p>若我们输入其他错误字符时，若需要报错，则需要正在通过map函数查找字符对应的优先数的函数中<code>int prior(oper op1, oper op2)</code>进行</p><p>在其中加入以下代码</p><pre><code class="c++">int prior(oper op1, oper op2)&#123;+if(p_num.find(op1)==p_num.end()||p_num[op1].left==0)&#123; //如果找不到运算符的优先数||左优先数=0+printf(&quot;错误的运算符：%c\n【程序即将终止】&quot;,op1);+exit (-1);//异常退出，终止程序+&#125;+if(p_num.find(op2)==p_num.end()||p_num[op1].right==0)&#123; //如果找不到运算符的优先数||右优先数=0+printf(&quot;错误的运算符：%c\n【程序即将终止】&quot;,op2);+exit (-1);+&#125;    return p_num[op1].left - p_num[op2].right;&#125;</code></pre><p>若我们在没有左括号的情况下输入右括号，报错，则需要在<code>字符</code>压入栈之前判断</p><pre><code class="c++">operand solve()/****************************************** 2. 输入下一个运算符op；* 3. while(prior(h.top(),op)&lt;0)*    栈顶元素出栈并计算；* 4. if(prior(h.top(),op)==0)结束；* 5. if(prior(h.top(),op)&gt;0) h.push(op);*******************************************/&#123;    operand x, y;    oper op;    history.push(&#39;=&#39;);    while(1)    &#123;    //scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40=;3+C0=两个符号合起来，2L10=，2 10 L= ，L 2 10 =；1 2 3 + *=     scanf(&quot; %c&quot;,&amp;op);//预读下一位数     if(op==&#39;,&#39;) continue;//if(op是数字)    if(isdigit(op)) &#123;//isdigiy判断是否是数字         ungetc(op, stdin);//还回字符 ,还给stdin（键盘）         scanf(&quot;%f&quot;,&amp;x);        operands.push(x);        continue;     &#125;    while(prior(history.top(),op)&lt;0)&#123;        operands.push(calc());        history.pop();    &#125;+if(op==&#39;)&#39;)&#123;+if(history.top()!=&#39;(&#39;)&#123;+printf(&quot;请检测：有没有成对括号\n截止目前，计算&quot;); +break;+&#125;            history.pop();            continue;        &#125;         if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;</code></pre><h2 id="三、问题解决完毕"><a href="#三、问题解决完毕" class="headerlink" title="三、问题解决完毕"></a>三、问题解决完毕</h2><p>目前我们需要解决的问题有两种，即：</p><h5 id="1-加入括号进行运算-1"><a href="#1-加入括号进行运算-1" class="headerlink" title="1.加入括号进行运算"></a>1.加入括号进行运算</h5><h5 id="2-优化报错方法-1"><a href="#2-优化报错方法-1" class="headerlink" title="2.优化报错方法"></a>2.优化报错方法</h5><p>而这两种在上面已经基本上解决了，至此完结~（撒花）</p><p>下面附上更改后的代码</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;math.h&gt;typedef char oper;typedef float operand;std::stack&lt;oper&gt; history;std::stack&lt;operand&gt; operands;/*优先数表*/struct prv_num_t&#123;char left,right;&#125;;std::map&lt;oper, prv_num_t&gt;  p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;, &#123;100,100&#125;&#125;,    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;,     &#123;&#39;L&#39;,&#123;22,21&#125;&#125;,//对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先     &#123;&#39;S&#39;,&#123;22,21&#125;&#125;,//定义sin函数     &#123;&#39;C&#39;,&#123;22,21&#125;&#125;,//定义cos函数;     &#123;&#39;(&#39;,&#123;99,1&#125;&#125;,    &#123;&#39;)&#39;,&#123;0,99&#125;&#125;,//0作为错误标志 &#125;;//&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 0-9 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 10-19 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 20-29 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 30-39 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;41,42&#125;,&#123;81,82&#125;,&#123;0,0&#125;,&#123;81,82&#125;,&#123;0,0&#125;,&#123;41,42&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 40-49 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 50-59 *///&#123;0,0&#125;,&#123;100,100&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 60-69 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 70-79 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 80-89 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 90-99 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 100-109 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;, /* 110-119 *///&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125;,&#123;0,0&#125; /* 120-127 *///&#125;;//43 45 42 47 61/*op1在左，op2在右*/ /*返回值为负：op1优先级高于op2*//*返回值为正：op2优先级高于op1*//*返回值为0：op1优先级等于op2*/int prior(oper op1, oper op2)&#123;    if(p_num.find(op1)==p_num.end()||p_num[op1].left==0)&#123; //如果找不到运算符    printf(&quot;错误的运算符：%c\n【程序即将终止】&quot;,op1);    exit (-1);    &#125;    if(p_num.find(op2)==p_num.end()||p_num[op1].right==0)&#123; //如果找不到运算符    printf(&quot;错误的运算符：%c\n【程序即将终止】&quot;,op2);    exit (-1);    &#125;    return p_num[op1].left - p_num[op2].right;&#125;#include&lt;ctype.h&gt;//判断字符类型 #include&lt;string.h&gt; operand calc()&#123;    operand x, y;//if(history.top()是双目运算符)&#123;    if(strchr(&quot;+-*/^L&quot;,history.top()))&#123;//strchr在 &quot;+-*/^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】         y = operands.top();        operands.pop();    &#125;    x = operands.top();    operands.pop();    switch(history.top())&#123;        case &#39;+&#39;: return x+y;        case &#39;-&#39;: return x-y;        case &#39;*&#39;: return x*y;        case &#39;/&#39;: return x/y;        case &#39;^&#39;: return pow(x,y);        case &#39;L&#39;: return log(y)/log(x);//log c库的对数换底公式         case &#39;S&#39;: return sin(y); //case &#39;S&#39;: operands.push(x); return sin(y);         case &#39;C&#39;: return cos(y); //case &#39;C&#39;: operands.push(x); return cos(y);    &#125;    printf(&quot;Err&quot;);    return -1;&#125;operand solve()/****************************************** 2. 输入下一个运算符op；* 3. while(prior(h.top(),op)&lt;0)*    栈顶元素出栈并计算；* 4. if(prior(h.top(),op)==0)结束；* 5. if(prior(h.top(),op)&gt;0) h.push(op);*******************************************/&#123;    operand x, y;    oper op;    history.push(&#39;=&#39;);    while(1)    &#123;    //scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40=;3+C0=两个符号合起来，2L10=，2 10 L= ，L 2 10 =；1 2 3 + *=     scanf(&quot; %c&quot;,&amp;op);//预读下一位数     if(op==&#39;,&#39;) continue;//if(op是数字)    if(isdigit(op)) &#123;//isdigiy判断是否是数字         ungetc(op, stdin);//还回字符 ,还给stdin（键盘）         scanf(&quot;%f&quot;,&amp;x);        operands.push(x);        continue;     &#125;    while(prior(history.top(),op)&lt;0)&#123;        operands.push(calc());        history.pop();    &#125;        if(op==&#39;)&#39;)&#123;            if(history.top()!=&#39;(&#39;)&#123;                printf(&quot;请检测：有没有成对括号\n截止目前，计算&quot;);                 break;            &#125;            history.pop();            continue;        &#125;         if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;int main()&#123;//printf(&quot;%d %d %d %d %d&quot;, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;=&#39;);return 0;    printf(&quot;%g\n&quot;, solve());    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【实例1の更新1】表达式求值——加入新的单目运算符</title>
      <link href="/example-optimization-1.html"/>
      <url>/example-optimization-1.html</url>
      
        <content type="html"><![CDATA[<p>前段时间我们学习了利用stack实现五种运算符的运算：<a href="https://kcsj.i-nmb.cn/example.html">【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)</a></p><p>实际上我们的表达式求值中并不是只有这5种运算，他还包括了 指数、对数以及三角函数等等。</p><p>今天我们就在原基础上逐一的实现 <code>指数、对数以及三角函数</code> 的表达式求值</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>之前，在<a href="https://kcsj.i-nmb.cn/example.html">【实例】表达式求值——利用stack实现五种运算符的运算 | 《课程设计》笔记 (i-nmb.cn)</a>中，我们做出了一下代码</p><pre><code class="C++">#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;typedef char oper;//运算符typedef float operand;/*优先数表*/struct prv_num_t&#123;char left,right;&#125;;//定义结构体 prv_num_t  _t代表类型 //关键字只包含一部分数据项,就称为map//关键字包含全部数据项,成为 std::map&lt;oper, prv_num_t&gt; p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;,&#123;100,100&#125;&#125;&#125;;/*op1在左，op2在右*//*返回值为负: op1优先级高于op2*//*返回值为正: op2优先级高于op1*//*返回值为0: op1优先级等于op2*/int prior(oper op1, oper op2)&#123;    return p_num[op1].left - p_num[op2].right;&#125;operand solve()&#123;    operand x, y;    oper op;    std::stack&lt;oper&gt; history;//历史栈     std::stack&lt;operand&gt; operands;    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈     while(1)&#123;/*****************************************2.  输入下一个运算符op;*3.  while（h.top()比op优先）&#123;栈顶元素出栈计算；&#125;*4.  if(h.top()==&#39;=&#39;&amp;&amp; op==&#39;=&#39;)&#123;结束&#125;*5.  h.push(op);*6.  转2。******************************************/        scanf(&quot;%f %c&quot;,&amp;x,&amp;op);        operands.push(x);        while(prior(history.top(), op)&lt;0)&#123;                        y = operands.top();            operands.pop();            x = operands.top();            operands.pop();            switch(history.top())&#123;                case &#39;+&#39;: operands.push(x + y) ; break;                case &#39;-&#39;: operands.push(x - y) ; break;                case &#39;*&#39;: operands.push(x * y) ; break;                case &#39;/&#39;: operands.push(x / y) ; break;            &#125;            history.pop();        &#125;        if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;int main()&#123;    printf(&quot;%g\n&quot;,solve());        return 0;&#125; </code></pre><p>今天的实例更新，是建立再此代码基础上的</p><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>1、优化之前的代码</p><p>2、逐一的实现 <code>指数、对数以及三角函数</code> 的表达式求值</p><h2 id="1-优化代码"><a href="#1-优化代码" class="headerlink" title="1.优化代码"></a>1.优化代码</h2><p>在加入新功能之前，我们先审视之前我们敲击的代码，我们在<code>operand solve()&#123;&#125;</code>函数中使用了以下循环</p><pre><code class="c++">operand solve()&#123;    while(1)&#123;    ……………………………………………………        while(prior(history.top(), op)&lt;0)&#123;            y = operands.top();            operands.pop();            x = operands.top();            operands.pop();            switch(history.top())&#123;                case &#39;+&#39;: operands.push(x + y) ; break;                case &#39;-&#39;: operands.push(x - y) ; break;                case &#39;*&#39;: operands.push(x * y) ; break;                case &#39;/&#39;: operands.push(x / y) ; break;        &#125;        ……………………………………    &#125;    …………………………………………&#125;</code></pre><p>这个循环实质上是一个运算核心，放在循环中，总是不太合适。</p><p>所以我们把他提取出来，改造成一个函数<code>operand calc()&#123;&#125;</code>，返回类型为之前定义的operand（操作数）</p><p><code>operand calc()</code>在循环while(prior(history.top(),op)&lt;0)返回运算结果，若输入出错，则输出Err，返回-1</p><pre><code class="c++">operand calc()&#123;    operand x, y;    y = operands.top();    operands.pop();    x = operands.top();    operands.pop();    switch(history.top())&#123;        case &#39;+&#39;: return x+y;//当运算符为+时，在循环while(prior(history.top(),op)&lt;0)返回x+y运算结果        case &#39;-&#39;: return x-y;//当运算符为-时，在循环while(prior(history.top(),op)&lt;0)返回x-y运算结果        case &#39;*&#39;: return x*y;//当运算符为*时，在循环while(prior(history.top(),op)&lt;0)返回x*y运算结果        case &#39;/&#39;: return x/y;//当运算符为/时，在循环while(prior(history.top(),op)&lt;0)返回x/y运算结果    &#125;    printf(&quot;Err&quot;);    return -1;&#125;</code></pre><p>而原<code>while(prior(history.top(), op)&lt;0)&#123;&#125;</code>循环体中改为</p><pre><code class="c++">    while(prior(history.top(),op)&lt;0)&#123;        operands.push(calc());        history.pop();    &#125;</code></pre><p>最后将以下代码设置为全局变量</p><pre><code>    std::stack&lt;oper&gt; history;//历史栈     std::stack&lt;operand&gt; operands;</code></pre><p>至此优化结束，优化后的总代码为：</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;typedef char oper;//运算符typedef float operand;std::stack&lt;oper&gt; history;//历史栈 std::stack&lt;operand&gt; operands;/*优先数表*/struct prv_num_t&#123;char left,right;&#125;;//定义结构体 prv_num_t  _t代表类型 //关键字只包含一部分数据项,就称为map//关键字包含全部数据项,成为 std::map&lt;oper, prv_num_t&gt; p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;,&#123;100,100&#125;&#125;&#125;;/*op1在左，op2在右*//*返回值为负: op1优先级高于op2*//*返回值为正: op2优先级高于op1*//*返回值为0: op1优先级等于op2*/int prior(oper op1, oper op2)&#123;    return p_num[op1].left - p_num[op2].right;&#125;operand calc()&#123;    operand x, y;    y = operands.top();    operands.pop();    x = operands.top();    operands.pop();    switch(history.top())&#123;        case &#39;+&#39;: return x+y;        case &#39;-&#39;: return x-y;        case &#39;*&#39;: return x*y;        case &#39;/&#39;: return x/y;    &#125;    printf(&quot;Err&quot;);    return -1;&#125;operand solve()&#123;    operand x, y;    oper op;    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈     while(1)&#123;/*****************************************2.  输入下一个运算符op;*3.  while（h.top()比op优先）&#123;栈顶元素出栈计算；&#125;*4.  if(h.top()==&#39;=&#39;&amp;&amp; op==&#39;=&#39;)&#123;结束&#125;*5.  h.push(op);*6.  转2。******************************************/        scanf(&quot;%f %c&quot;,&amp;x,&amp;op);        operands.push(x);        while(prior(history.top(), op)&lt;0)&#123;            operands.push(calc());            history.pop();        &#125;        if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;int main()&#123;    printf(&quot;%g\n&quot;,solve());        return 0;&#125; </code></pre><h2 id="2-增加指数运算和对数运算符"><a href="#2-增加指数运算和对数运算符" class="headerlink" title="2.增加指数运算和对数运算符"></a>2.增加指数运算和对数运算符</h2><h3 id="增加指数运算符"><a href="#增加指数运算符" class="headerlink" title="增加指数运算符"></a>增加指数运算符</h3><p>增加指数运算相对简单，在map（<code>std::map&lt;oper, prv_num_t&gt; p_num</code>）里面增加<code>&#123;&quot;关键字&quot;,&#123;左优先数,右优先数&#125;&#125;</code>，左优先级大于右优先（从左到右运算）【2^3^2&#x3D;&#x3D;64!&#x3D;2^(3^2)】</p><p>即</p><pre><code class="c++">std::map&lt;oper, prv_num_t&gt; p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;,&#123;100,100&#125;&#125;,    +    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;    &#125;;</code></pre><p>并且在运算函数<code>calc()&#123;&#125;</code>加入返回运算值</p><p>即</p><pre><code class="c++">    case &#39;*&#39;: return x*y;    case &#39;/&#39;: return x/y;+case &#39;^&#39;: return pow(x,y);&#125;printf(&quot;Err&quot;);</code></pre><p>因为用到了pow函数，所以我们在头文件加入<code>#include&lt;math.h&gt;</code></p><p>至此，增加指数运算符操作结束</p><h3 id="增加对数运算符"><a href="#增加对数运算符" class="headerlink" title="增加对数运算符"></a>增加对数运算符</h3><p>同理</p><p>在map（<code>std::map&lt;oper, prv_num_t&gt; p_num</code>）里面增加<code>&#123;&quot;关键字&quot;,&#123;左优先数,右优先数&#125;&#125;</code>，左优先级小于右优先（从右到左运算）【log （2,log(2,8))&#x3D;3】</p><pre><code class="c++">std::map&lt;oper, prv_num_t&gt;  p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;, &#123;100,100&#125;&#125;,    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;,     +&#123;&#39;L&#39;,&#123;22,21&#125;&#125;//对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先     &#125;printf(&quot;Err&quot;);</code></pre><p>在运算函数<code>calc()&#123;&#125;</code>加入返回运算值</p><pre><code class="c++">    case &#39;*&#39;: return x*y;    case &#39;/&#39;: return x/y;    case &#39;^&#39;: return pow(x,y);    +case &#39;L&#39;: return log(y)/log(x);//对数换底公式 ,以x（先输入的数）为底数&#125;printf(&quot;Err&quot;);</code></pre><p>至此，增加对数运算符操作结束</p><p>试试<code>2L8=</code> 答案是3</p><h2 id="3-增加三角函数（单目运算符）"><a href="#3-增加三角函数（单目运算符）" class="headerlink" title="3.增加三角函数（单目运算符）"></a>3.增加三角函数（单目运算符）</h2><p>在map添加关键字</p><pre><code>std::map&lt;oper, prv_num_t&gt;  p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;, &#123;100,100&#125;&#125;,    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;,     &#123;&#39;L&#39;,&#123;22,21&#125;&#125;,//对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先     +    &#123;&#39;S&#39;,&#123;22,21&#125;&#125;,//定义sin函数 +&#123;&#39;C&#39;,&#123;22,21&#125;&#125;,//定义cos函数; &#125;printf(&quot;Err&quot;);</code></pre><p>在运算函数<code>calc()&#123;&#125;</code>加入返回运算值</p><pre><code class="c++">    case &#39;*&#39;: return x*y;    case &#39;/&#39;: return x/y;    case &#39;^&#39;: return pow(x,y);    case &#39;L&#39;: return log(y)/log(x);//对数换底公式 ,以x（先输入的数）为底数+case &#39;S&#39;: return sin(y); +case &#39;C&#39;: return cos(y); &#125;printf(&quot;Err&quot;);</code></pre><p>至此，增加三角函数符号</p><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>之前我们增加的是双目运算符，遵循着 <code>&#39;操作数&#39; &#39;运算符&#39; &#39;操作数&#39;</code></p><p>现在，我们的单目运算符，遵循 <code>&#39;运算符&#39; &#39;操作数&#39;</code></p><h3 id="一、输入模式不同的解决办法"><a href="#一、输入模式不同的解决办法" class="headerlink" title="一、输入模式不同的解决办法"></a>一、输入模式不同的解决办法</h3><p>二者输入模式不同，怎么办？难道之前辛苦搭建的程序崩塌了？</p><p>其实我们输入表达式的时候已经将完整的表达式输入了，<strong>此时我们只需要判断下一位是不是运算符，而进行对应计算，也就是<u>预读下一位数</u></strong></p><p><strong>预读下一位数如果是数字，那么返还给键盘（模拟键盘重新输入）</strong></p><p><strong>预读下一位数如果不是数字，那么作为op（运算符）</strong></p><p>所以在<code>while(1)&#123;&#125;</code>处，更改以下代码</p><pre><code class="c++">while(1)&#123;/*****************************************2.  输入下一个运算符op;*3.  while（h.top()比op优先）&#123;栈顶元素出栈计算；&#125;*4.  if(h.top()==&#39;=&#39;&amp;&amp; op==&#39;=&#39;)&#123;结束&#125;*5.  h.push(op);*6.  转2。******************************************/-scanf(&quot;%f %c&quot;,&amp;x,&amp;op);//scanf(&quot;%f %c&quot;,&amp;x,&amp;op); 3+40=;3+C0=两个符号合起来-operands.push(x);    +scanf(&quot; %c&quot;,&amp;op);//预读下一位数 +if(isdigit(op)) &#123;//isdigiy判断是否是数字 //if(op是数字) #include&lt;ctype.h&gt;//判断字符类型 +ungetc(op, stdin);//还回字符 ,还给stdin（键盘）+scanf(&quot;%f&quot;,&amp;x);+operands.push(x);+continue; +&#125;</code></pre><p>并且增加头文件<code>#include&lt;ctype.h&gt;</code> </p><p>此时输入模式不同的问题得以解决</p><h3 id="二、运算模式不同的解决"><a href="#二、运算模式不同的解决" class="headerlink" title="二、运算模式不同的解决"></a>二、运算模式不同的解决</h3><p>如果是双目运算符，那么我们操作数栈的操作如下</p><pre><code class="c++">y = operands.top();operands.pop();x = operands.top();operands.pop();</code></pre><p>由此可见，我们在运算双目运算符的时候，把y赋予栈顶值，然后弹出栈顶以获取下一个数来赋予x，之后再一次弹出栈顶</p><p><strong>相当于一个双目运算符运算过后，弹出两个数</strong></p><p>而如果用单目运算符运算，只需要运算一个数</p><p>也就是说，<strong>单目运算符运算过后，弹出一个数</strong></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>我们需要判断运算符是单目运算符还是双目运算符</p><pre><code class="c++">    if(history.top()是双目运算符)&#123;        y = operands.top();        operands.pop();    &#125;</code></pre><p>如果是双目运算符我们就弹多走1个栈顶</p><p>​<code>if(history.top()是双目运算符)</code>我们使用<code>if(strchr(&quot;+-*/^L&quot;,history.top()))</code>实现</p><p>也就是在<code>operand calc()</code>函数中做以下操作</p><pre><code class="c++">operand calc()&#123;    operand x, y;    -y = operands.top();-operands.pop();+if(strchr(&quot;+-*/^L&quot;,history.top()))&#123;//strchr在 &quot;+-*/^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】 +y = operands.top();+operands.pop();+&#125;        x = operands.top();    operands.pop();    switch(history.top())&#123;        case &#39;+&#39;: return x+y;        case &#39;-&#39;: return x-y;        case &#39;*&#39;: return x*y;        case &#39;/&#39;: return x/y;        case &#39;^&#39;: return pow(x,y);        case &#39;L&#39;: return log(y)/log(x);//log c库的对数换底公式         case &#39;S&#39;: return sin(y);        case &#39;C&#39;: return cos(y);     &#125;    printf(&quot;Err&quot;);    return -1;&#125;</code></pre><p>我们引用了<code>strchr(&quot;+-*/^L&quot;,history.top())</code>因此需要加入<code>#include&lt;string.h&gt;</code> </p><p>问题解决</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>处理完毕后最终代码如下</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;math.h&gt;typedef char oper;//运算符typedef float operand;std::stack&lt;oper&gt; history;//历史栈 std::stack&lt;operand&gt; operands;/*优先数表*/struct prv_num_t&#123;char left,right;&#125;;//定义结构体 prv_num_t  _t代表类型 //关键字只包含一部分数据项,就称为map//关键字包含全部数据项,成为 std::map&lt;oper, prv_num_t&gt; p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;,&#123;100,100&#125;&#125;,    &#123;&#39;^&#39;,&#123;32,31&#125;&#125;,     &#123;&#39;L&#39;,&#123;22,21&#125;&#125;,//对数运算符log(x,y) ；log (x,log(x,x)) ，右边优先     &#123;&#39;S&#39;,&#123;22,21&#125;&#125;,//定义sin函数     &#123;&#39;C&#39;,&#123;22,21&#125;&#125;,//定义cos函数; &#125;;/*op1在左，op2在右*//*返回值为负: op1优先级高于op2*//*返回值为正: op2优先级高于op1*//*返回值为0: op1优先级等于op2*/int prior(oper op1, oper op2)&#123;    return p_num[op1].left - p_num[op2].right;&#125;#include&lt;string.h&gt;operand calc()&#123;    operand x, y;//if(history.top()是双目运算符)&#123;    if(strchr(&quot;+-*/^L&quot;,history.top()))&#123;//strchr在 &quot;+-*/^L&quot;找到 history.top()，如果找到返回位置，找不到返回空值【用来判断（整数和0）】         y = operands.top();        operands.pop();    &#125;    x = operands.top();    operands.pop();    switch(history.top())&#123;        case &#39;+&#39;: return x+y;        case &#39;-&#39;: return x-y;        case &#39;*&#39;: return x*y;        case &#39;/&#39;: return x/y;        case &#39;^&#39;: return pow(x,y);        case &#39;L&#39;: return log(y)/log(x);//log c库的对数换底公式        case &#39;S&#39;: return sin(y);         case &#39;C&#39;: return cos(y);     &#125;    printf(&quot;Err&quot;);    return -1;&#125;operand solve()&#123;    operand x, y;    oper op;    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈     while(1)&#123;/*****************************************2.  输入下一个运算符op;*3.  while（h.top()比op优先）&#123;栈顶元素出栈计算；&#125;*4.  if(h.top()==&#39;=&#39;&amp;&amp; op==&#39;=&#39;)&#123;结束&#125;*5.  h.push(op);*6.  转2。******************************************/    scanf(&quot; %c&quot;,&amp;op);//预读下一位数 //if(op是数字)    if(isdigit(op)) &#123;//isdigiy判断是否是数字         ungetc(op, stdin);//还回字符 ,还给stdin（键盘）         scanf(&quot;%f&quot;,&amp;x);        operands.push(x);        continue;     &#125;        while(prior(history.top(), op)&lt;0)&#123;            operands.push(calc());            history.pop();        &#125;        if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;int main()&#123;    printf(&quot;%g\n&quot;,solve());        return 0;&#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【实例1】表达式求值——利用stack实现五种运算符的运算</title>
      <link href="/example.html"/>
      <url>/example.html</url>
      
        <content type="html"><![CDATA[<p>看了标题有人会问，运算符的运算实现？直接printf(“%d”,a+b*c);不就完了么？</p><p>当然没有那么简单！</p><p>本篇带读者走进如何用stack来实现加减乘除运算</p><h2 id="原则：没有解决方案之前绝不能试图开始编程"><a href="#原则：没有解决方案之前绝不能试图开始编程" class="headerlink" title="[原则：没有解决方案之前绝不能试图开始编程]"></a>[原则：没有解决方案之前绝不能试图开始编程]</h2><p>在我们拿到题目后，有些读者习惯于直接开始敲代码，我觉得这样不方便思路的养成。所以 没有解决方案之前绝不能试图开始编程</p><p>那么解决方案哪里来？！探索解决方案，可以从百度来，可以问专业学者等等。</p><h2 id="解决方案一-算符优先文法"><a href="#解决方案一-算符优先文法" class="headerlink" title="[解决方案一:算符优先文法]"></a>[解决方案一:算符优先文法]</h2><p>给不同运算符赋予“优先级”的概念<br>优先级相同的运算符按照结合性的顺序计算（从左到右或从右到左）<br>为了更简单地比较不同运算符的优先级<br>给每个运算符定义一个称为<strong>“优先数”的整数（以下优先数越小，优先级越高）</strong></p><pre><code class="c++">+：81，82-：81，82*：41，42/：41，42=：100，1003+4*5+2=</code></pre><p>确定运算顺序:专家告诉我们：使用计算栈h（保存元素是运算符）<br>{a1, a2,…, an, k} 此时，k是watch dog，也就是哨兵<br>for (i&#x3D;1 ;ai !&#x3D;k ; ++k) ;</p><h2 id="实践方案"><a href="#实践方案" class="headerlink" title="实践方案"></a>实践方案</h2><ol><li><p>h.push(‘&#x3D;’);&#x2F;&#x2F; 用于判断结束，例如：若输入<code>6=</code>(当栈顶的&#x3D;和输入的&#x3D;匹配，则结束)</p></li><li><p>输入下一个运算符op;</p></li><li><p>while（h.top()比op优先）{栈顶元素出栈计算；}</p></li><li><p>if(h.top()&#x3D;&#x3D;’&#x3D;’&amp;&amp; op&#x3D;&#x3D;’&#x3D;’){结束}</p></li><li><p>h.push(op);</p></li><li><p>转2。（循环）</p></li></ol><h3 id="首先，根据实践方案进行初始化"><a href="#首先，根据实践方案进行初始化" class="headerlink" title="首先，根据实践方案进行初始化"></a>首先，根据实践方案进行初始化</h3><p>根据上述实践方案，我们可以知道我们需要用到stack、stdio.h的头文件，并且需要用到oper（运算符）、和operand（操作数）,而运算符是char型，操作数为float型</p><p>所以我们在文件头需要编写以下代码</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;stack&gt;typedef char oper;//运算符typedef float operand;</code></pre><h3 id="其次，建立实践方案对应的函数"><a href="#其次，建立实践方案对应的函数" class="headerlink" title="其次，建立实践方案对应的函数"></a>其次，建立实践方案对应的函数</h3><p>我们初始化完成后，如果要解决问题，则需要建立解决问题的函数</p><p>于是我们建立一个名为<code>solve</code>的函数，因为是处理数据的，将要返回处理数据的数值，而数值的类型上述定义是<code>operand</code>类型</p><p>需要加入<code>operand solve()&#123;&#125;</code>函数。</p><p>我们在处理运算符时，需要判断运算符的优先级，我们需要一个函数判断左边和右边优先级大小，所以我们引入一个函数 根据定义的一个称为<strong>“优先数”的整数</strong>（优先数越小，优先级越高）来判断优先级大小。</p><p>我们使用<code>int prior(oper op1, oper op2)&#123;&#125;</code>，根据优先数相减得到的int型的正负值判断，其中<code>op1</code>为左符号类型为定义的<code>oper</code>，<code>op2</code>为右符号（新符号）</p><p>最后使用必须要有main函数<code>main()&#123;&#125;</code></p><p>所以构造完毕后，总代码如下</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;stack&gt;typedef char oper;//运算符typedef float operand;//运算数int prior(oper op1, oper op2)&#123;    return;&#125;operand solve()&#123;    return;&#125;main()&#123;    &#125;</code></pre><h3 id="处理函数的丰富"><a href="#处理函数的丰富" class="headerlink" title="处理函数的丰富"></a>处理函数的丰富</h3><p>我们主要的处理函数是<code>operand solve()</code></p><p>最简单的加减乘除运算是拥有两个数和一个运算符组成，所以我们要先定义两个数和运算符</p><p>我们还需要两个栈（一个存放操作数，一个存放操作符）</p><p>完善函数如下</p><pre><code class="c++">operand solute()&#123;    operand x, y;    oper op;    std::stack&lt;oper&gt; history;//历史栈 ,存放历史操作符号    std::stack&lt;operand&gt; operands;//存放操作数&#125;</code></pre><p>我们根据<a href="#%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88"><strong>实践方案（点击转到）</strong></a></p><blockquote><ol><li><p>h.push(‘&#x3D;’);&#x2F;&#x2F; 用于判断结束，例如：若输入<code>6=</code>(当栈顶的&#x3D;和输入的&#x3D;匹配，则结束)</p></li><li><p>输入下一个运算符op;</p></li><li><p>while（h.top()比op优先）{</p></li></ol><p>​栈顶元素出栈计算；</p><p>}</p><ol start="4"><li><p>if(h.top()&#x3D;&#x3D;’&#x3D;’&amp;&amp; op&#x3D;&#x3D;’&#x3D;’){结束}（若有等号匹配，则结束循环）</p></li><li><p>h.push(op);</p></li><li><p>转2。（循环）</p></li></ol></blockquote><h4 id="1-h-push-‘-x3D-’"><a href="#1-h-push-‘-x3D-’" class="headerlink" title="1.h.push(‘&#x3D;’);"></a>1.h.push(‘&#x3D;’);</h4><p>那么我们添加<code>history.push(&#39;=&#39;);</code>输入等号，whach dog（士兵）进栈 </p><pre><code class="c++">operand solute()&#123;    operand x, y;    oper op;    std::stack&lt;oper&gt; history;//历史栈 ,存放历史操作符号    std::stack&lt;operand&gt; operands;//存放操作数    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈 &#125;</code></pre><h4 id="2-步骤2-5循环，直到若有等号匹配，则结束循环；"><a href="#2-步骤2-5循环，直到若有等号匹配，则结束循环；" class="headerlink" title="2.步骤2-5循环，直到若有等号匹配，则结束循环；"></a>2.步骤2-5循环，直到若有等号匹配，则结束循环；</h4><p>所以我们加入循环条件</p><pre><code class="c++">operand solute()&#123;    operand x, y;    oper op;    std::stack&lt;oper&gt; history;//历史栈 ,存放历史操作符号    std::stack&lt;operand&gt; operands;//存放操作数    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈         while(1)&#123;                if(prior(history.top(),op)==0) break;    &#125;&#125;</code></pre><h4 id="3-输入下一个数和运算符op"><a href="#3-输入下一个数和运算符op" class="headerlink" title="3.输入下一个数和运算符op;"></a>3.输入下一个数和运算符op;</h4><p>我们需要在循环体中持续不断的输入数和运算符</p><p>观察式子：<code>3+2+1*5=</code>、<code>5*8/7-4=</code>、<code>9*8/7-5=</code></p><p>我们发现，我们输入的每个数字后面有且仅有一个运算符</p><p>所以我们加入</p><pre><code class="c++">scanf(&quot;%f %c&quot;,&amp;x,&amp;op);//输入一个数字和一个字符        operands.push(x);//将数字压入存放操作数的栈</code></pre><h4 id="4-栈顶元素出栈计算；"><a href="#4-栈顶元素出栈计算；" class="headerlink" title="4.栈顶元素出栈计算；"></a>4.栈顶元素出栈计算；</h4><p>我们需要判断运算符的优先级，如果存放历史操作符号的栈顶比op优先，（优先数越小，优先级越高），那么直接计算历史操作数链接的两个数</p><p>示意图如下</p><img src="https://img1.i-nmb.cn/img/image-20220522224804731.png" alt="image-20220522224804731" style="zoom:67%;" /><p>所以我们根据</p><blockquote><ol start="3"><li>while（h.top()比op优先）{</li></ol><p>​栈顶元素出栈计算；</p><p>}</p></blockquote><p>进行栈顶元素出栈计算；</p><p>所以写出以下循环</p><pre><code class="c++">while（h.top()比op优先）&#123;    y = operands.top();//让y为最新的数（优先级高的历史操作符的右边的数）    operands.pop();//弹走最新的数（优先级高的历史操作符的右边的数）    x = operands.top();//让x为优先级高的历史操作符的左边的数    operands.pop();//弹走历史操作符的左边的数    switch(history.top())&#123;//判断优先级高的历史操作符        case &#39;+&#39;: operands.push(x + y) ; break;        case &#39;-&#39;: operands.push(x - y) ; break;        case &#39;*&#39;: operands.push(x * y) ; break;        case &#39;/&#39;: operands.push(x / y) ; break;    &#125;    history.pop();//弹走历史操作符的栈顶&#125;</code></pre><p>接下来我们需要对比<code>history.top()</code>【历史操作符（上一次的运算符号）】和<code>op</code>【即将压入history栈的符号】优先</p><p>通过之前的函数<code>int prior(oper op1, oper op2)</code>进行丰富，</p><p>又因为<strong>优先数越小，优先级越高</strong>，所以我们判断优先数的做差，判断差的正负性就可以判断优先级。</p><p>我们完善函数<code>int prior(oper op1, oper op2)</code></p><pre><code class="c++">int prior(oper op1, oper op2)&#123;    return p_num[op1].left - p_num[op2].right;&#125;</code></pre><p>从而完善循环判断</p><pre><code class="c++">while（prior(history.top(), op)&lt;0）&#123;    y = operands.top();//让y为最新的数（优先级高的历史操作符的右边的数）    operands.pop();//弹走最新的数（优先级高的历史操作符的右边的数）    x = operands.top();//让x为优先级高的历史操作符的左边的数    ………………………………………………</code></pre><h4 id="5-h-push-op-压入op"><a href="#5-h-push-op-压入op" class="headerlink" title="5.h.push(op);压入op"></a>5.h.push(op);压入op</h4><p>若优先级不大于栈顶的优先级，要将op压入history栈<code>history.push(op);</code>，此操作要在判断是否为等号之后</p><p>即</p><pre><code class="c++">operand solve()&#123;    operand x, y;    oper op;    std::stack&lt;oper&gt; history;//历史栈     std::stack&lt;operand&gt; operands;    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈     while(1)&#123;/********************2.  输入下一个运算符op;*3.  while（h.top()比op优先）&#123;栈顶元素出栈计算；&#125;*4.  if(h.top()==&#39;=&#39;&amp;&amp; op==&#39;=&#39;)&#123;结束&#125;*5.  h.push(op);*6.  转2。********************/        scanf(&quot;%f %c&quot;,&amp;x,&amp;op);        operands.push(x);        while(prior(history.top(), op)&lt;0)&#123;            y = operands.top();            operands.pop();            x = operands.top();            operands.pop();            switch(history.top())&#123;                case &#39;+&#39;: operands.push(x + y) ; break;                case &#39;-&#39;: operands.push(x - y) ; break;                case &#39;*&#39;: operands.push(x * y) ; break;                case &#39;/&#39;: operands.push(x / y) ; break;            &#125;            history.pop();        &#125;        if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;</code></pre><h4 id="6-函数的完善"><a href="#6-函数的完善" class="headerlink" title="6.函数的完善"></a>6.函数的完善</h4><p>我们的解决函数<code>operand solve()&#123;&#125;</code>趋近完美，但是程序是由<code>main()&#123;&#125;</code>开始</p><p>所以我们要完善main函数</p><pre><code class="c++">int main()&#123;    printf(&quot;%g\n&quot;,solve());    return 0;&#125;</code></pre><p>在函数<code>int prior(oper op1, oper op2)&#123;&#125;</code>中，我们没有赋予<code>p_num[op1].left</code>（左符号、旧符号）和<code>p_num[op2].right</code>（右符号、新符号）的值（优先数）。所以我们在函数<code>int prior(oper op1, oper op2)&#123;&#125;</code>之前加入以下代码，并且加入<code>#include&lt;map&gt;</code></p><pre><code class="c++">struct prv_num_t&#123;char left,right;&#125;;//定义结构体 prv_num_t  _t代表类型 //关键字只包含一部分数据项,就称为mapstd::map&lt;oper, prv_num_t&gt; p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;,&#123;100,100&#125;&#125;&#125;;</code></pre><img src="https://img1.i-nmb.cn/img/image-20220522232910691.png" alt="计算优先数的示意图" style="zoom:80%;" /><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>最终获得代码</p><pre><code class="c++">#include&lt;stdio.h&gt;#include&lt;stack&gt;#include&lt;map&gt;typedef char oper;//运算符typedef float operand;/*优先数表*/struct prv_num_t&#123;char left,right;&#125;;//定义结构体 prv_num_t  _t代表类型 //关键字只包含一部分数据项,就称为map//关键字包含全部数据项,成为 std::map&lt;oper, prv_num_t&gt; p_num=&#123;    &#123;&#39;+&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;-&#39;,&#123;81,82&#125;&#125;,    &#123;&#39;*&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;/&#39;,&#123;41,42&#125;&#125;,    &#123;&#39;=&#39;,&#123;100,100&#125;&#125;&#125;;/*op1在左，op2在右*//*返回值为负: op1优先级高于op2*//*返回值为正: op2优先级高于op1*//*返回值为0: op1优先级等于op2*/int prior(oper op1, oper op2)&#123;    return p_num[op1].left - p_num[op2].right;&#125;operand solute()&#123;    operand x, y;    oper op;    std::stack&lt;oper&gt; history;//历史栈     std::stack&lt;operand&gt; operands;    history.push(&#39;=&#39;);//输入等号，whach dog（士兵）进栈     while(1)&#123;/*****************************************2.  输入下一个运算符op;*3.  while（h.top()比op优先）&#123;栈顶元素出栈计算；&#125;*4.  if(h.top()==&#39;=&#39;&amp;&amp; op==&#39;=&#39;)&#123;结束&#125;*5.  h.push(op);*6.  转2。******************************************/        scanf(&quot;%f %c&quot;,&amp;x,&amp;op);        operands.push(x);        while(prior(history.top(), op)&lt;0)&#123;                        y = operands.top();            operands.pop();            x = operands.top();            operands.pop();            switch(history.top())&#123;                case &#39;+&#39;: operands.push(x + y) ; break;                case &#39;-&#39;: operands.push(x - y) ; break;                case &#39;*&#39;: operands.push(x * y) ; break;                case &#39;/&#39;: operands.push(x / y) ; break;            &#125;            history.pop();        &#125;        if(prior(history.top(),op)==0) break;        history.push(op);    &#125;    return operands.top();&#125;int main()&#123;    printf(&quot;%g\n&quot;,solute());        return 0;&#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL 线性结构</title>
      <link href="/STL-linear-structure.html"/>
      <url>/STL-linear-structure.html</url>
      
        <content type="html"><![CDATA[<p>如果写c++程序那么STL容器是不可避免要使用的，而正确合理地使用这些容器才能够简化我们的程序、提高运行的效率，所以本篇根据2022-05-22《数据结构课程设计》来记录 STL线性结构 笔记</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>如何输出6的二进制数？</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p><strong>问题-&gt;解决方案-&gt;实现方案-&gt;编写</strong></p><p>即</p><p>从问题得到解决方案（解决方案（具体步骤（过程可以问专业专家）））</p><p>实现方案有哪几种方法，并进行优化</p><p>编写代码</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><strong>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。</strong></p><p>具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="一、使用stack【栈】输出"><a href="#一、使用stack【栈】输出" class="headerlink" title="一、使用stack【栈】输出"></a>一、使用stack【栈】输出</h3><p>因为 <u>将得到的余数作为二进制数的高位有效位依次排列起来</u> 的过程需要后进先出，所以我们使用栈进行输出</p><p>老师给出代码如下</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;list&gt;#include&lt;stack&gt;main()&#123;    std::list&lt;int&gt; q; //定义（双向）链表（被除数q） #include&lt;list&gt;    std::stack&lt;int&gt; r;//定义栈（余数r）#include&lt;stack&gt;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n!=0)&#123;        q.push_back(n/2);//push_back链表的后面插入          r.push(n%2); //push余数压入栈         n=n/2;    &#125;     while(!r.empty())&#123;// empty()只返回真假值，栈空返回1，否则返回0     printf(&quot;%d&quot;,r.top());//top有返回值，而pop没有返回值 ，//用stack倒叙输出     r.pop();    &#125;    return 0;&#125;</code></pre><p>其中<code>std::list&lt;int&gt; q;</code> 定义（双向）<strong>链表</strong> 来记录<u>商q</u>；<code>std::stack&lt;int&gt; r</code> 定义 <strong>栈</strong> 来记录<u>余数r</u>，定义n来表示操作数（要变为2进制的数）</p><p>利用循环1来“压进”处理的数据：将<strong>商</strong>压进 链表的后面（<code>q.push_back(n/2)</code>）；将余数 压入栈 <code>r.push(n%2);</code> ；随后将n&#x2F;2向下取整（int型）</p><pre><code class="c++">while(n!=0)&#123;        q.push_back(n/2);//push_back链表的后面插入          r.push(n%2); //push余数压入栈         n=n/2;&#125; </code></pre><p>利用循环2来输出：将 压入栈 <code>r.push(n%2);</code>  的元素从栈顶输出<code>printf(&quot;%d&quot;,r.top());</code>随后销毁栈顶元素[目的是为了让下一个元素输出]<code>r.pop();</code></p><pre><code class="c++">while(!r.empty())&#123;// empty()只返回真假值，栈空返回1，否则返回0     printf(&quot;%d&quot;,r.top());//top有返回值，而pop没有返回值 ，//用stack倒叙输出     r.pop();&#125;</code></pre><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>我们发现，在输出时候，我们并没有输出双向链表<code>std::list&lt;int&gt; q;</code>，</p><p>所以我们可以判断，双向链表是多余的，需要优化（但是思考实现方案的时候不能不考虑到双向链表）</p><p>我们把list相关代码删除（或注释）</p><p>得到</p><pre><code class="c++">#include&lt;cstdio&gt;//#include&lt;list&gt;#include&lt;stack&gt;main()&#123;//std::list&lt;int&gt; q; //定义（双向）链表（被除数q） #include&lt;list&gt;    std::stack&lt;int&gt; r;//定义栈（余数r）#include&lt;stack&gt;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n!=0)&#123;    //q.push_back(n/2);商（不用输出）//push_back链表的后面插入          r.push(n%2); //push余数压入栈         n=n/2;    &#125;     while(!r.empty())&#123;// empty()只返回真假值，栈空返回1，否则返回0     printf(&quot;%d&quot;,r.top());//top有返回值，而pop没有返回值 ，//用stack倒叙输出     r.pop();    &#125;    return 0;&#125;</code></pre><h3 id="二、使用list【链式存储】输出"><a href="#二、使用list【链式存储】输出" class="headerlink" title="二、使用list【链式存储】输出"></a>二、使用list【链式存储】输出</h3><p>具有三种实现list输出方案：</p><h4 id="1）使用r-push-back-n-2-加上reverse"><a href="#1）使用r-push-back-n-2-加上reverse" class="headerlink" title="1）使用r.push_back(n%2);加上reverse"></a>1）使用r.push_back(n%2);加上reverse</h4><p>因为 <u>将得到的余数作为二进制数的高位有效位依次排列起来</u> 的过程需要后进先出，若我们需要使用list【链式存储】输出，要先将链式存储的顺序进行交换</p><p>那么我们需要用到的是reverse函数，具体代码如下</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;list&gt;main()&#123;    std::list&lt;int&gt; r;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n!=0)&#123;         r.push_back(n%2);        n=n/2;    &#125;         reverse(r.begin(),r.end());//【或者】r.reverse;    //auto *i;auto:自动类型推倒//std::list&lt;int&gt;::iterator ;    for(auto i=r.begin();i!=r.end();++i)        printf(&quot;%d&quot;,*i) ;    return 0;&#125;</code></pre><p>其中<code>reverse(r.begin(),r.end());</code>为交换顺序函数，将链表排序颠倒（1,2,3-&gt;3,2,1）</p><p>在输出时，我们要用到类似指针的<code>i</code>，但是它的类型我们并不知道（或者不想写），那么我们使用<code>auto i</code>，让编译器自动识别</p><blockquote><p>不过在使用时需要如下配置</p><p><img src="https://img1.i-nmb.cn/img/image-20220522134832991.png" alt="编译时加入以下命令"></p></blockquote><h4 id="2）使用r-push-back-n-2-利用属性改为rbigin，rend"><a href="#2）使用r-push-back-n-2-利用属性改为rbigin，rend" class="headerlink" title="2）使用r.push_back(n%2);利用属性改为rbigin，rend"></a>2）使用r.push_back(n%2);利用属性改为rbigin，rend</h4><p>利用双向链表的属性，我们可以重后往前输出</p><p><strong>注意</strong>：双向链表不是数列，不能将上述<code>for(auto i=r.begin();i!=r.end();++i)</code>用<code>for(auto i=r.end();i!=r.begin();i--)</code>，而是要将<code>r.begin()</code>改为<code>r.rbegin</code>，<code>r.end</code>改为<code>r.rend</code>,即改为<code>for(auto i=r.rbegin();i!=r.rend();++i)</code></p><p>具体代码如下</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;list&gt;main()&#123;    std::list&lt;int&gt; r;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n!=0)&#123;         r.push_back(n%2);         n=n/2;    &#125;     //auto *i;auto:自动类型推倒//std::list&lt;int&gt;::iterator ;    for(auto i=r.rbegin();i!=r.rend();++i)// begin变成rbegin， end改为rend，双向链表从后向前读取     printf(&quot;%d&quot;,*i) ;    return 0;&#125;</code></pre><h4 id="3）使用r-push-front-n-2"><a href="#3）使用r-push-front-n-2" class="headerlink" title="3）使用r.push_front(n%2);"></a>3）使用r.push_front(n%2);</h4><p><u>将得到的余数作为二进制数的高位有效位依次排列起来</u> 的过程需要后进先出，我们还可以在插入时从链表头插入<code>r.push_front(n%2)</code></p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;list&gt;main()&#123;    std::list&lt;int&gt; r;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n!=0)&#123;         push_front(n%2);// push_front(n%2)（从前插入）顺序等于reverse(r.begin(),r.end())【或者】;数序颠倒，1,2,3-&gt;3,2,1 ,        n=n/2;    &#125;     for(auto i=r.begin();i!=r.end();++i)    printf(&quot;%d&quot;,*i) ;    return 0;&#125;</code></pre><h3 id="三、vector【顺序存储，数组】输出"><a href="#三、vector【顺序存储，数组】输出" class="headerlink" title="三、vector【顺序存储，数组】输出"></a>三、vector【顺序存储，数组】输出</h3><p>同使用list【链式存储】输出一样，我们可以</p><p><strong>1）使用r.push_back(n%2);加上reverse</strong></p><p>方法同list，只不过将list替换为vector</p><p><strong>2）使用r.push_back(n%2);利用属性改为rbigin，rend</strong></p><p>方法同list，只不过将list替换为vector</p><p>但是我们<u>不能使用<code>r.push_front(n%2);</code></u> ，因为vector作为顺序存储（数组），不能从头输入，只能从尾输入。即没有<code>r.push_front()</code></p><p><strong>vector具有数组特性，我们可以使用数组的方法进行输出</strong> <strong>（不建议）</strong></p><p>即使用</p><pre><code class="c++">for(int i=r.size();i&gt;0;--i)        printf(&quot;%d&quot;,r[i]) ;</code></pre><p>得到：</p><pre><code class="c++">#include&lt;cstdio&gt;#include&lt;vector&gt;main()&#123;    std::vector&lt;int&gt; r;    int n;    scanf(&quot;%d&quot;,&amp;n);    while(n!=0)&#123;         r.push_back(n%2);         n=n/2;    &#125;    for(int i=r.size();i&gt;0;--i)        printf(&quot;%d&quot;,r[i]) ;//数组从r[max]输出到r[1](r[0]为空)    return 0;&#125;</code></pre><h3 id="四、双端队列deque【deque-是-double-ended-queue-的缩写，又称双端队列容器。】"><a href="#四、双端队列deque【deque-是-double-ended-queue-的缩写，又称双端队列容器。】" class="headerlink" title="四、双端队列deque【deque 是 double-ended queue 的缩写，又称双端队列容器。】"></a>四、双端队列deque【deque 是 double-ended queue 的缩写，又称双端队列容器。】</h3><p>和 vector 不同的是，deque 还擅长在序列头部添加或删除元素</p><p>deque的内存模型相比于vector与list要复杂许多，它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。向deque 两端添加或删除元素的开销很小，它不需要重新分配空间。</p><p>具体模型见下图：</p><p><img src="https://img1.i-nmb.cn/img/image-20220522141449464.png" alt="image-20220522141449464"></p><p>他能支持上述所有方式：</p><p><strong>1）使用r.push_back(n%2);加上reverse</strong></p><p><strong>2）使用r.push_back(n%2);利用属性改为rbigin，rend</strong></p><p><strong>3）使用r.push_front(n%2);</strong> </p><p><strong>4）具有数组特性，可以使用数组的方法进行输出</strong> <strong>（不建议）</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线性结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好！世界！</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>这是本博客的第一篇！加油！</p><p>本博客为了记录《2022课程设计（大一 下）》的知识点而被设计与使用</p><p>加油兄弟们</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
